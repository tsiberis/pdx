# -*- coding: utf-8 -*-
"""
/***************************************************************************
 pdx
                                 A QGIS plugin
 Αυτοματοποίηση λειτουργιών πδχ
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        started coding       : 2025-04-05
        ended                : 2025-09-03
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Takis Tsiberis
        email                : tsiberis@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program was written with notepad++                               *
 *   https://notepad-plus-plus.org/                                        *
 *                                                                         *
 *   and with the help of AI                                               *
 *   https://deepai.org/chat                                               *
 *                                                                         *
 ***************************************************************************/
"""
#-------------------Imports-------------------
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction

# Initialize Qt resources from file resources.py
from .resources import *

# Import the code for the dialog
from ._pdx_dialog import pdxDialog

# Custom imports
import os, docx
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT
from docx.oxml import OxmlElement
from docx.oxml.ns import qn
from math import ceil
from sip import wrapinstance

from qgis import processing
from qgis.utils import iface
from qgis.core import edit, QgsFeature, QgsLineString, QgsPolygon, QgsField, QgsVectorFileWriter, QgsVectorLayer, QgsProject, QgsWkbTypes, QgsLayout, QgsPrintLayout, QgsLayoutItemMap, QgsLayoutItemLabel, QgsLayoutPoint, QgsLayoutSize, QgsUnitTypes, QgsLayoutExporter, QgsLayoutMeasurement, QgsLayoutItemMapGrid, QgsLayoutItemScaleBar, QgsScaleBarSettings, QgsRectangle, QgsLayoutItemPicture, QgsFillSymbol, QgsLinePatternFillSymbolLayer, QgsLayoutItemMapOverview, QgsLayoutItemShape, QgsLayerTreeGroup
from PyQt5.QtCore import QVariant, QSizeF, QPointF
from PyQt5.QtGui import QFont, QColor
from qgis.PyQt.QtCore import QRectF, Qt

#-------------------Constants-------------------
kyromenos = 'ΔΑΣΙΚΟΣ_ΧΑΡΤΗΣ'
antirriseis = 'ΟΛΕΣ_ΟΙ_ΑΝΤΙΡΡΗΣΕΙΣ'
exaireseis = 'ΟΛΕΣ_ΟΙ_ΕΞΑΙΡΕΣΕΙΣ'
kanavos = 'ΚΑΝΑΒΟΣ'
FILENAME2 = "_activity.txt"
FLAGNAME = 'Greece.png'
NORTH = 'northarrow.svg'
PROJECT = QgsProject.instance()
KRITIRIO = 0.0001

#-------------------Classes-------------------
class pdx:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'pdx_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&pistopoihtika')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('pdx', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/_pdx/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'pdx'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&pistopoihtika'),
                action)
            self.iface.removeToolBarIcon(action)

    def _print(self,a):
        with open(FILENAME2, "a") as f:
            f.write(a + "\n")
        self.dlg.label_2.setText(a)

    def _recalculate_the_area_field(self,a):
        a.startEditing()
        area_field = 'AREA'
        for feature in a.getFeatures():
            geom = feature.geometry()
            area = geom.area()
            feature[area_field] = area
            a.updateFeature(feature)
        a.commitChanges()

    def _intersect(self,a,b):
        layer_a = PROJECT.mapLayersByName(a)[0]
        layer_b = PROJECT.mapLayersByName(b)[0]

        # Define the parameters for the intersection
        params = {
            'INPUT': layer_a,
            'OVERLAY': layer_b,
            'OUTPUT': 'memory:'  # Output to memory for demonstration
        }

        # Run the intersection processing algorithm
        result1 = processing.run("native:intersection", params)

        # Retrieve the resulting layer
        intersected_layer = result1['OUTPUT']

        # Now define parameters for the multipart to singlepart algorithm
        params = {
            'INPUT': intersected_layer,
            'OUTPUT': 'memory:'
        }

        # Run the multipart to singlepart algorithm
        result2 = processing.run('native:multiparttosingleparts', params)

        # Retrieve the resulting layer
        singlepart_layer = result2['OUTPUT']

        return singlepart_layer

    def dxf_to_shp(self):
        # Remove previous layers (if any) from the project
        possible_layer_names = ['Κτήμα','Αγροτικά','Δασικά','Αντιρρήσεις','Εξαιρέσεις','Αντιρρήσεις_2']
        for layer in PROJECT.mapLayers().values():
            if layer.name() in possible_layer_names:
                PROJECT.removeMapLayer(layer.id())

        # Load the DXF file
        dxf_layer = QgsVectorLayer(self.dlg.lineEdit_8.text(), 'DXFLayer', 'ogr')
        if not dxf_layer.isValid():
            self._print("Failed to load the DXF layer...")
            return 0
        else:
            # Create a new memory layer for polygons
            polygon_layer = QgsVectorLayer('Polygon?crs=EPSG:2100', 'Polygons', 'memory')
            provider = polygon_layer.dataProvider()

            # Add fields to the polygon layer
            provider.addAttributes([QgsField('id', QVariant.Int)])
            polygon_layer.updateFields()

            # Iterate through the LineString features in the DXF layer
            for feature in dxf_layer.getFeatures():
                geom = feature.geometry()
                if geom.isMultipart() == False:
                    line_string = QgsLineString(feature.geometry().asPolyline())
                    self._print("Adding polyline...")

                    # Create a polygon from the LineString
                    polygon_geom = QgsPolygon(line_string)

                    # Create a new feature for the polygon layer
                    polygon_feature = QgsFeature()
                    polygon_feature.setGeometry(polygon_geom)
                    polygon_feature.setAttributes([feature.id()])

                    # Add the feature to the polygon layer
                    with edit(polygon_layer):
                        polygon_layer.addFeature(polygon_feature)

            # Save the polygon layer to a Shapefile
            output_path = os.path.dirname(self.dlg.lineEdit_8.text()) + "/" + 'dxf_output.shp'
            dxf2shp_writer = QgsVectorFileWriter.writeAsVectorFormat(
                polygon_layer,
                output_path,
                'windows-1253',
                polygon_layer.crs(),
                'ESRI Shapefile'
            )
            self._print("Polygon Shapefile created successfully! in " + output_path)

            # Finalize and close the writer
            del dxf2shp_writer

            # Create a vector layer from the shapefile
            _layer = QgsVectorLayer(output_path, 'Κτήμα', 'ogr')

            # Check if the layer is valid
            if not _layer.isValid():
                self._print("Shapefile failed to load...")
                return 0
            else:
                # Add an AREA field
                with edit(_layer):
                    new_field = QgsField('AREA', QVariant.Double)
                    _layer.dataProvider().addAttributes([new_field])
                    _layer.updateFields()
                self._recalculate_the_area_field(_layer)
                # Add the layer to the QGIS project
                PROJECT.addMapLayer(_layer)
                # Zoom to the layer's extent
                self.iface.mapCanvas().setExtent(_layer.extent())
                self.iface.mapCanvas().refresh()

                self._print("Shapefile loaded successfully!")
                return 1

    def agrotika_to_shp(self):
        _inter = self._intersect('Κτήμα', kyromenos)

        # Recalculate the area field
        self._recalculate_the_area_field(_inter)

        agr_ids_to_select = []
        for feature in _inter.getFeatures():
            # Accessing the feature ID
            feature_id = feature.id()

            # Accessing the field names of interest directly
            _area = feature['AREA']
            _char = feature['KATHGORDX']

            # Apply the criteria for 'agrotika'
            if _area >= KRITIRIO:
                if 'ΑΑ' in _char or 'ΠΑ' in _char or 'ΑA' in _char or 'AΑ' in _char or 'AA' in _char or 'ΠA' in _char:
                    agr_ids_to_select.append(feature_id)

        # Select all the 'agrotika'
        if agr_ids_to_select:
            _inter.selectByIds(agr_ids_to_select)

            output2_path = os.path.dirname(self.dlg.lineEdit_8.text()) + "/" + 'Αγροτικά.shp'

            # Create a new temporary memory layer to store selected features
            agrotika_writer = QgsVectorFileWriter(output2_path, 'windows-1253', _inter.fields(), QgsWkbTypes.Polygon, _inter.crs(), 'ESRI Shapefile')

            # Iterate over selected features and add them to the new layer
            for feature in _inter.selectedFeatures():
                agrotika_writer.addFeature(feature)

            # Finalize and close the writer
            del agrotika_writer

            self._print('Selected features exported successfully to: ' + output2_path)

            # Create a vector layer from the shapefile
            _agr_layer = QgsVectorLayer(output2_path, 'Αγροτικά', 'ogr')

            # Add the layer to the QGIS project
            PROJECT.addMapLayer(_agr_layer)
            self._print("Shapefile Αγροτικά loaded successfully!")
            del _inter
            return 1
        else:
            self._print('Δεν υπάρχουν καθόλου αγροτικά τμήματα...')
            del _inter
            return 0

    def dasika_to_shp(self):
        _inter = self._intersect('Κτήμα', kyromenos)

        # Recalculate the area field
        self._recalculate_the_area_field(_inter)

        das_ids_to_select = []
        for feature in _inter.getFeatures():
            # Accessing the feature ID
            feature_id = feature.id()

            # Accessing the field names of interest directly
            _area = feature['AREA']
            _char = feature['KATHGORDX']

            # Apply the criteria for 'dasika'
            if _area >= KRITIRIO:
                if 'Δ' in _char or 'Χ' in _char or 'X' in _char:
                    das_ids_to_select.append(feature_id)

        # Select all the 'dasika'
        if das_ids_to_select:
            _inter.selectByIds(das_ids_to_select)

            output2_path = os.path.dirname(self.dlg.lineEdit_8.text()) + "/" + 'Δασικά.shp'

            # Create a new temporary memory layer to store selected features
            dasika_writer = QgsVectorFileWriter(output2_path, 'windows-1253', _inter.fields(), QgsWkbTypes.Polygon, _inter.crs(), 'ESRI Shapefile')

            # Iterate over selected features and add them to the new layer
            for feature in _inter.selectedFeatures():
                dasika_writer.addFeature(feature)

            # Finalize and close the writer
            del dasika_writer

            self._print('Selected features exported successfully to: ' + output2_path)

            # Create a vector layer from the shapefile
            _das_layer = QgsVectorLayer(output2_path, 'Δασικά', 'ogr')

            # Add the layer to the QGIS project
            PROJECT.addMapLayer(_das_layer)
            self._print("Shapefile Δασικά loaded successfully!")
            del _inter
            return 1
        else:
            self._print('Δεν υπάρχουν καθόλου δασικά τμήματα...')
            del _inter
            return 0

    def antir_to_shp(self):
        _inter = self._intersect('Κτήμα', antirriseis)

        # Check if layer contains features
        if _inter.featureCount() > 0:

            # Recalculate the area field
            self._recalculate_the_area_field(_inter)

            antir_ids_to_select = []
            for feature in _inter.getFeatures():
                # Accessing the feature ID
                feature_id = feature.id()

                # Accessing the area field directly
                _area = feature['AREA']

                # Apply the criteria for 'αντιρρήσεις'
                if _area >= KRITIRIO:
                    antir_ids_to_select.append(feature_id)

            # Select all the 'αντιρρήσεις'
            if antir_ids_to_select:
                _inter.selectByIds(antir_ids_to_select)

                output3_path = os.path.dirname(self.dlg.lineEdit_8.text()) + "/" + 'Αντιρρήσεις.shp'

                # Create a new temporary memory layer to store selected features
                antir_writer = QgsVectorFileWriter(output3_path, 'windows-1253', _inter.fields(), QgsWkbTypes.Polygon, _inter.crs(), 'ESRI Shapefile')

                # Iterate over selected features and add them to the new layer
                for feature in _inter.selectedFeatures():
                    antir_writer.addFeature(feature)

                # Finalize and close the writer
                del antir_writer

                self._print('Selected features exported successfully to: ' + output3_path)

                # Create a vector layer from the shapefile
                _antir_layer = QgsVectorLayer(output3_path, 'Αντιρρήσεις', 'ogr')

                # Add the layer to the QGIS project
                PROJECT.addMapLayer(_antir_layer)
                self._print("Shapefile Αντιρρήσεις loaded successfully!")
                del _inter
                return 1
            else:
                self._print('Δεν υπάρχουν καθόλου τμήματα αντιρρήσεων...')
                del _inter
                return 0
        else:
            self._print('Δεν υπάρχουν καθόλου τμήματα αντιρρήσεων...')
            del _inter
            return 0

    def exair_to_shp(self):
        _inter = self._intersect('Κτήμα', exaireseis)

        # Check if layer contains features
        if _inter.featureCount() > 0:

            # Recalculate the area field
            self._recalculate_the_area_field(_inter)

            exair_ids_to_select = []
            for feature in _inter.getFeatures():
                # Accessing the feature ID
                feature_id = feature.id()

                # Accessing the area field directly
                _area = feature['AREA']

                # Apply the criteria for 'εξαιρέσεις'
                if _area >= KRITIRIO:
                    exair_ids_to_select.append(feature_id)

            # Select all the 'εξαιρέσεις'
            if exair_ids_to_select:
                _inter.selectByIds(exair_ids_to_select)

                output4_path = os.path.dirname(self.dlg.lineEdit_8.text()) + "/" + 'Εξαιρέσεις.shp'

                # Create a new temporary memory layer to store selected features
                exair_writer = QgsVectorFileWriter(output4_path, 'windows-1253', _inter.fields(), QgsWkbTypes.Polygon, _inter.crs(), 'ESRI Shapefile')

                # Iterate over selected features and add them to the new layer
                for feature in _inter.selectedFeatures():
                    exair_writer.addFeature(feature)

                # Finalize and close the writer
                del exair_writer

                self._print('Selected features exported successfully to: ' + output4_path)

                # Create a vector layer from the shapefile
                _exair_layer = QgsVectorLayer(output4_path, 'Εξαιρέσεις', 'ogr')

                # Add the layer to the QGIS project
                PROJECT.addMapLayer(_exair_layer)
                self._print("Shapefile Εξαιρέσεις loaded successfully!")
                del _inter
                return 1
            else:
                self._print('Δεν υπάρχουν καθόλου τμήματα εξαιρέσεων...')
                del _inter
                return 0
        else:
            self._print('Δεν υπάρχουν καθόλου τμήματα εξαιρέσεων...')
            del _inter
            return 0

    def antir_to_exair(self):
        _inter = self._intersect('Αντιρρήσεις', 'Εξαιρέσεις')

        # Check if layer contains features
        if _inter.featureCount() > 0:
            # Load the layers
            input_layer1 = PROJECT.mapLayersByName('Αντιρρήσεις')[0]
            input_layer2 = PROJECT.mapLayersByName('Εξαιρέσεις')[0]

            output5_path = os.path.dirname(self.dlg.lineEdit_8.text()) + "/" + 'Αντιρρήσεις_2.shp'

            # Define the parameters for the difference
            params = {
                'INPUT': input_layer1,
                'OVERLAY': input_layer2,
                'OUTPUT': 'memory:'
            }

            # Run the difference processing algorithm
            result1 = processing.run("native:difference", params)

            # Retrieve the resulting layer
            difference_layer = result1['OUTPUT']

            # Now define parameters for the multipart to singlepart algorithm
            params = {
                'INPUT': difference_layer,
                'OUTPUT': output5_path
            }

            # Run the multipart to singlepart algorithm
            processing.run('native:multiparttosingleparts', params)

            # Create a vector layer from the shapefile
            _diafor_layer = QgsVectorLayer(output5_path, 'Αντιρρήσεις_2', 'ogr')

            # Recalculate the area field
            self._recalculate_the_area_field(_diafor_layer)

            # Remove the 'Αντιρρήσεις' layer from the project
            layer_name = 'Αντιρρήσεις'
            for layer in PROJECT.mapLayers().values():
                if layer.name() == layer_name:
                    PROJECT.removeMapLayer(layer.id())

            # Add the new layer to the QGIS project
            PROJECT.addMapLayer(_diafor_layer)

            self._print('Από τις αντιρρήσεις αφαιρέθηκαν οι εξαιρέσεις ανάρτησης!')
            del _inter
            return 1
        else:
            del _inter
            return 0

    def coords(self, geom):
        if geom.isMultipart():
            polygons = geom.asMultiPolygon()
        else:
            polygons = [geom.asPolygon()]

        coordinate_list = ''
        for polygon in polygons:
            for j, ring in enumerate(polygon):
                for point in ring:
                    _x_ = "{:.4f}".format(point.x())
                    _y_ = "{:.4f}".format(point.y())
                    coordinate_list += 'Χ=' + _x_ + ' ' + 'Υ=' + _y_ + '\n'
                if j < len(polygon) - 1:coordinate_list += "\nΕξαιρείται\n"
        return coordinate_list[:-1]

    def compare_shp_areas(self,a,b):
        flag = 0
        layer1 = PROJECT.mapLayersByName(a)[0]
        layer2 = PROJECT.mapLayersByName(b)[0]

        # Extract all 'area' values
        areas_layer1 = [f['area'] for f in layer1.getFeatures() if f['area'] is not None]
        areas_layer2 = [f['area'] for f in layer2.getFeatures() if f['area'] is not None]

        # Sort the area lists
        areas_layer1.sort()
        areas_layer2.sort()

        # Compare lengths first
        if len(areas_layer1) != len(areas_layer2):
            self._print("Number of features differs between layers.")
        else:
            # Compare cell by cell
            for index, (area1, area2) in enumerate(zip(areas_layer1, areas_layer2)):
                if abs(area1 - area2) > 1e-6:  # Use a tolerance for floating point comparison
                    self._print(f"Mismatch at index {index}: Layer1 area = {area1}, Layer2 area = {area2}")
                    break
            else:
                self._print("All areas match after sorting!!!")
                flag = 1
        return flag

    def simple_count(self,a):
        count = 0
        layer = PROJECT.mapLayersByName(a)[0]
        for feature in layer.getFeatures():
            count += 1
        return count

    def das_info(self,a):
        das_list = []
        count = 0
        ret_str = ''
        layer = PROJECT.mapLayersByName(a)[0]
        for feature in layer.getFeatures():
            das_value = feature['KATHGORDX']
            an_value = feature['KATHGORAL1']
            if an_value in ['AN','AΝ','ΑN','ΑΝ']: das_value += '-ΑΝ'
            if das_value not in das_list:
                das_list.append(das_value)
            count += 1
        das_list.sort()
        if len(das_list) == 1:
            ret_str = das_list[0]
        elif len(das_list) == 2:
            ret_str = das_list[0] + ' & ' + das_list[1]
        else:
            for x in range(len(das_list)):
                if x == len(das_list)-2:
                    c = ' & '
                elif x == len(das_list)-1:
                    c = ''
                else:
                    c = ', '
                ret_str += das_list[x] + c
        return [ret_str, count]

    def compare_DKAMK(self,embadon,dkamk):
        layer = PROJECT.mapLayersByName(kyromenos)[0]

        # Initialize a variable to store the AREA value
        area_value = None

        # Iterate over features in the layer
        for feature in layer.getFeatures():
            # Check if the DKAMK field matches the target value
            if feature['DKAMK'] == dkamk:
                # Retrieve the AREA value
                area_value = feature['AREA']
                # Exit the loop once found
                break

        result = ''
        if abs(area_value - embadon) > 1e-6:  # Use a tolerance for floating point comparison
            result = 'Τμήμα του ' + dkamk
        else:
            result = dkamk
        return result

    def set_cell_borders(self, cell, border_color='000000', border_width=4):
        tc = cell._element
        tcPr = tc.get_or_add_tcPr()
        for edge in ('top', 'left', 'bottom', 'right'):
            border = OxmlElement(f'w:{edge}')
            border.set(qn('w:val'), 'single')
            border.set(qn('w:sz'), str(border_width))
            border.set(qn('w:color'), border_color)
            border.set(qn('w:space'), '0')
            # Remove existing border if present
            existing = tcPr.find(qn(f'w:{edge}'))
            if existing is not None:
                tcPr.remove(existing)
            tcPr.append(border)

    def transform(self,number):
        # Format number with comma as thousands separator and 4 decimal places
        s = f"{number:,.4f}"
        # Replace the comma with a placeholder to avoid conflicts
        s = s.replace(",", "_")
        # Replace the period (decimal point) with comma
        s = s.replace(".", ",")
        # Replace the placeholder with period (thousands separator)
        s = s.replace("_", ".")
        return s

    def normalize_scale(self,a):
        s = a.scale()
        _scale = 0
        if s < 100: _scale = 50
        elif 150 < s < 200: _scale = 150
        elif 250 < s < 300: _scale = 250
        else: _scale = ceil(s / 100) * 100
        if _scale > 1000: _scale += 100
        _scale += 100
        a.setScale(_scale,True)
        return _scale

    def normalize_kanavos_scale(self,a):
        s = a.scale()
        _scale = 0
        if s <= 5000: _scale = 5000
        elif 5000    < s <= 10000:    _scale = 10000
        elif 10000   < s <= 50000:    _scale = 50000
        elif 50000   < s <= 100000:   _scale = 100000
        elif 100000  < s <= 500000:   _scale = 500000
        elif 500000  < s <= 1000000:  _scale = 1000000
        elif 1000000 < s <= 5000000:  _scale = 5000000
        elif 5000000 < s <= 10000000: _scale = 10000000
        else: _scale = 50000000
        a.setScale(_scale,True)
        return _scale

    def update_centroids(self, a):
        layer = PROJECT.mapLayersByName(a)[0]

        # Start editing
        layer.startEditing()

        # Get index of fields
        idx_x = layer.fields().indexOf('POLY_X_CO')
        idx_y = layer.fields().indexOf('POLY_Y_CO')

        for feature in layer.getFeatures():
            geom = feature.geometry()
            centroid = geom.centroid()
            centroid_point = centroid.asPoint()
            # Update the fields
            layer.changeAttributeValue(feature.id(), idx_x, centroid_point.x())
            layer.changeAttributeValue(feature.id(), idx_y, centroid_point.y())

        # Commit changes
        layer.commitChanges()
        self._print("Centroid coordinates updated.")

    def disable_layer(self,a,enable=0):
        # Get the layer tree (the layer panel tree)
        layer_tree = PROJECT.layerTreeRoot()
        # Find your layer by name or ID
        layer_name = a
        layer = PROJECT.mapLayersByName(layer_name)[0]
        # Disable (hide) the layer
        layer_node = layer_tree.findLayer(layer.id())
        if layer_node:
            if not enable:
                layer_node.setItemVisibilityChecked(False)
            else:
                layer_node.setItemVisibilityChecked(True)

    def hide_everything(self):
        # Get the root of the layer tree
        root = PROJECT.layerTreeRoot()
        for _group in root.children():
            _group.setItemVisibilityChecked(True)  # Enable the groups
            for _layer in _group.children():
                _layer.setItemVisibilityChecked(False)  # But hide the layers

    def enable_rasters(self):
        # Get the root of the layer tree
        root = PROJECT.layerTreeRoot()
        for _group in root.children():
            if _group.name() == 'RASTERS':
                for _layer in _group.children():
                    _layer.setItemVisibilityChecked(True)  # Show the rasters

    def gather_rasters(self):
        layers = []
        root = PROJECT.layerTreeRoot()
        for _group in root.children():
            if _group.name() == 'RASTERS':
                for child in _group.children():
                    layer = child.layer()
                    layers.append(layer)
        return layers

    def name_anad(self,a,b):
        if isinstance(b, QVariant):
            b_str = ''
        else:
            b_str = str(b)
        if b_str == '':
            return a
        else:
            return a + '-' + b_str

    def fit_layer_extent_to_layout_extent(self, layer):
        extent = layer.extent()
        # Calculate aspect ratios
        layer_ratio = extent.width() / extent.height()
        layout_ratio = 1
        # Determine new extent dimensions
        if layer_ratio > layout_ratio:
            # Width is the limiting factor
            new_width = extent.width()
            new_height = new_width / layout_ratio
        else:
            # Height is the limiting factor
            new_height = extent.height()
            new_width = new_height * layout_ratio
        # Center point of the original extent
        center = extent.center()
        # Create new extent with adjusted size
        new_extent = QgsRectangle(
            center.x() - new_width / 2,
            center.y() - new_height / 2,
            center.x() + new_width / 2,
            center.y() + new_height / 2
        )
        return new_extent

    def make_the_pdx(self):
        # Create a new Document
        doc = docx.Document()

        # Access Inches and Points through the docx.shared module
        inch = docx.shared.Inches
        pt = docx.shared.Pt

        # Access the section of the document
        section = doc.sections[0]

        # Set margins (in inches)
        section.top_margin = inch(3/2.54)     # Top margin
        section.bottom_margin = inch(2/2.54)  # Bottom margin
        section.left_margin = inch(2/2.54)    # Left margin
        section.right_margin = inch(2/2.54)   # Right margin

        # Add the first table
        table1 = doc.add_table(1, 2)

        # Access the cells
        cell1 = table1.cell(0, 0)
        cell2 = table1.cell(0, 1)
        cell1.width = inch(11/2.54)
        cell2.width = inch(6/2.54)

        # Access the first paragraph in the first cell; if none exists, add one
        if not cell1.paragraphs:
            paragraph1 = cell1.add_paragraph()
        else:
            paragraph1 = cell1.paragraphs[0]

        # Add a run and insert the image
        run1 = paragraph1.add_run()
        run1.font.size = pt(10)
        run1.text = "                 "
        flag_path = os.path.join(self.dlg.documents_folder, FLAGNAME)
        run1.add_picture(flag_path, width=inch(0.6654), height=inch(0.6772))

        # Add another run and insert text
        run2 = paragraph1.add_run()
        run2.font.name = 'Arial'
        run2.font.size = pt(10)
        run2.bold = True
        run2.text = "\nΕΛΛΗΝΙΚΗ ΔΗΜΟΚΡΑΤΙΑ\nΥΠΟΥΡΓΕΙΟ ΠΕΡΙΒΑΛΛΟΝΤΟΣ & ΕΝΕΡΓΕΙΑΣ\nΓΕΝΙΚΗ ΓΡΑΜΜΑΤΕΙΑ ΔΑΣΩΝ\nΕΠΙΘΕΩΡΗΣΗ ΕΦΑΡΜΟΓΗΣ "
        self.epitheorisi = self.dlg.comboBox.currentText()
        if self.epitheorisi in ['ΑΙΓΑΙΟΥ', 'ΑΤΤΙΚΗΣ', 'ΚΡΗΤΗΣ']:
            run2.text += 'ΔΑΣΙΚΗΣ ΠΟΛΙΤΙΚΗΣ ' + self.epitheorisi + '\n'
        else:
            run2.text += 'ΔΑΣΙΚΗΣ ΠΟΛΙΤΙΚΗΣ' + '\n' + self.epitheorisi + '\n'
        run2.text += 'ΔΙΕΥΘΥΝΣΗ ΔΑΣΩΝ '+self.dlg.comboBox_2.currentText()+'\nΤΜΗΜΑ ΔΑΣΙΚΩΝ ΧΑΡΤΟΓΡΑΦΗΣΕΩΝ'

        # And another run for text
        run3 = paragraph1.add_run()
        run3.font.name = 'Arial'
        run3.font.size = pt(10)
        run3.bold = False
        run3.text = '\nΤαχ. Δ/νση: ' + self.dlg.lineEdit.text()
        run3.text += '\nΠληροφορίες: ' + self.dlg.lineEdit_2.text()
        run3.text += '\nΤηλέφωνο: ' + self.dlg.lineEdit_3.text()
        run3.text += '\nΗλ. Ταχ/μείο: ' + self.dlg.lineEdit_4.text()

        # Access the first paragraph in the second cell; if none exists, add one
        if not cell2.paragraphs:
            paragraph2 = cell2.add_paragraph()
        else:
            paragraph2 = cell2.paragraphs[0]

        # Add a run and insert Date & Protocol number
        run4 = paragraph2.add_run()
        run4.font.name = 'Arial'
        run4.font.size = pt(10)
        run4.bold = False
        run4.italic = True
        run4.text = '\n\n\n'

        # Find the city where the forestry commission is located (edra)
        self.diefthinsi = self.dlg.comboBox_2.currentText()
        for value in self.dlg.EPITHEORISEIS[self.epitheorisi]:
            if value[0] == self.diefthinsi:
                self.edra = value[1]

        run4.text += self.edra + ', ' + self.dlg.lineEdit_10.text()
        run4.text += '\n' + 'Αρ. Πρωτ.: ' + self.dlg.lineEdit_9.text()
        run4.text += '\n\n\n\n'
        run4.text += 'Προς:\n'
        run4.text += self.dlg.plainTextEdit_3.toPlainText()

        # Add a 3rd paragraph with text
        paragraph3 = doc.add_paragraph()
        paragraph3.alignment = docx.enum.text.WD_PARAGRAPH_ALIGNMENT.CENTER
        run5 = paragraph3.add_run()
        run5.font.name = 'Arial'
        run5.font.size = pt(10)
        run5.bold = True
        run5.text = '\nΠΙΣΤΟΠΟΙΗΤΙΚΟ ΔΑΣΙΚΟΥ ΕΝ ΓΕΝΕΙ ΧΑΡΑΚΤΗΡΑ ΕΚΤΑΣΗΣ'

        # Add the 4th (main) paragraph with text
        paragraph4 = doc.add_paragraph()
        paragraph4.alignment = docx.enum.text.WD_PARAGRAPH_ALIGNMENT.JUSTIFY
        run6 = paragraph4.add_run()
        run6.font.name = 'Arial'
        run6.font.size = pt(10)
        run6.bold = False
        run6.text = "Σε απάντηση της υπ' αριθμόν " + self.dlg.lineEdit_5.text() + ' αίτησης ' + self.dlg.gender + self.dlg.lineEdit_6.text() + ' που αφορά στο υπό στοιχεία ' + self.dlg.plainTextEdit_4.toPlainText() + ' γεωτεμάχιο συνολικού εμβαδού ' + self.dlg.lineEdit_7.text() + ' τ.μ. και από τα στοιχεία του ' + self.dlg.partial + 'κυρωμένου δασικού χάρτη ' + self.dlg.plainTextEdit.toPlainText() + ', βεβαιώνεται ότι '

        if self.compare_shp_areas('Κτήμα','Δασικά'):
            run6.text += 'στο σύνολό του όπως εμφανίζεται στο συνημμένο απόσπασμα του παραπάνω χάρτη, το οποίο αποτελεί αναπόσπαστο τμήμα του παρόντος, με κατηγορία μορφής/κάλυψης δασικού χάρτη '
        else:
            run6.text += 'οι επί μέρους εκτάσεις των πολυγώνων που συνθέτουν αυτό και εμφανίζονται στο συνημμένο απόσπασμα του παραπάνω χάρτη, το οποίο αποτελεί αναπόσπαστο τμήμα του παρόντος, με κατηγορία μορφής/κάλυψης δασικού χάρτη '

        dsnf = self.das_info('Δασικά')
        run6.text += dsnf[0] + ' είναι δασικού εν γένει χαρακτήρα. '
        if dsnf[1] > 1:
            run6.text += 'Αναλυτικά τα πολύγωνα, οι συντεταγμένες των κορυφών τους και τα αντίστοιχα εμβαδά τους αναφέρονται στον παρακάτω πίνακα:'
        else:
            run6.text += 'Αναλυτικά το πολύγωνο, οι συντεταγμένες των κορυφών του και το αντίστοιχο εμβαδόν του αναφέρονται στον παρακάτω πίνακα:'

        # Work the attribute table
        self.update_centroids('Δασικά')
        d_layer = PROJECT.mapLayersByName('Δασικά')[0]

        features = d_layer.getFeatures()
        featureList = []
        for feat in features:
            featureList.append([round(feat.attributes()[1],4), self.coords(feat.geometry()), self.compare_DKAMK(feat.attributes()[1],feat.attributes()[16]), self.name_anad(feat.attributes()[7],feat.attributes()[8]), feat.attributes()[13], feat.attributes()[14]])

        featureList.sort(key=lambda x: -x[0])
        featureList.sort(key=lambda x: x[3])

        # Add a table with the needed rows and 5 columns
        table = doc.add_table(rows=dsnf[1]+1, cols=5)

        # Add column widths
        column_widths = [2.37, 2.28, 5.44, 4.47, 3.43]

        # Set the width of each cell
        for row in table.rows:
            for i, cell in enumerate(row.cells):
                cell.width = inch(column_widths[i]/2.54)

        # Add the header text
        header_titles = ['ΠΟΛΥΓΩΝΟ', 'ΕΜΒΑΔΟΝ\n(σε τ.μ.)', 'ΣΥΝΤΕΤΑΓΜΕΝΕΣ ΚΟΡΥΦΩΝ\nΠΟΛΥΓΩΝΟΥ (Χ,Υ)', 'ΔΑΣΙΚΟΣ ΚΩΔΙΚΟΣ\nΑΡΙΘΜΟΣ ΜΕΡΙΚΗΣ\nΚΥΡΩΣΗΣ (DKAMK)', 'ΚΑΤΗΓΟΡΙΑ\nΜΟΡΦΗΣ/ΚΑΛΥΨΗΣ\nΚΥΡΩΜΕΝΟΥ\nΔΑΣΙΚΟΥ ΧΑΡΤΗ']

        for i, cell in enumerate(table.rows[0].cells):
            self.set_cell_borders(cell)
            paragraph5 = cell.paragraphs[0]
            run7 = paragraph5.add_run(header_titles[i])
            run7.font.name = 'Arial'
            run7.font.size = pt(9)
            run7.font.bold = True
            paragraph5.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER

        # Fill data rows and prepare map labels
        map_labels = []
        for row_idx in range(dsnf[1]):
            emvadon = self.transform(featureList[row_idx][0])
            row_titles = [str(row_idx+1), emvadon, str(featureList[row_idx][1]), str(featureList[row_idx][2]), str(featureList[row_idx][3])]
            for col_idx, cell in enumerate(table.rows[row_idx+1].cells):
                self.set_cell_borders(cell)
                paragraph6 = cell.paragraphs[0]
                # Prepare the text based on your data
                cell_text = row_titles[col_idx]
                run8 = paragraph6.add_run(cell_text)
                run8.font.name = 'Arial'
                run8.font.size = pt(9)
                run8.font.bold = False
                paragraph6.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER
            map_labels.append(['Τμήμα '+str(row_idx+1)+': '+str(featureList[row_idx][3])+'\n'+emvadon+' τ.μ.',featureList[row_idx][4],featureList[row_idx][5]])

        # Add the last paragraph
        paragraph7 = doc.add_paragraph()
        paragraph7.alignment = docx.enum.text.WD_PARAGRAPH_ALIGNMENT.JUSTIFY
        run9 = paragraph7.add_run()
        run9.font.name = 'Arial'
        run9.font.size = pt(10)
        run9.bold = False
        run9.text = "\nΤο παρόν εκδίδεται κατ' εφαρμογή των παραγράφων 4 και 5 του άρθρου 20 του ν. 3889/2010 όπως ισχύει και συνοδεύεται από απόσπασμα του μερικώς κυρωμένου δασικού χάρτη. Τα στοιχεία που αναφέρονται στο παρόν είναι οριστικά και έχουν πλήρη αποδεικτική ισχύ σε κάθε διοικητική ή δικαστική αρχή για τα τμήματα που αποτελούν δασικές εν γένει εκτάσεις των παραγράφων 1, 2, 3, 4 και 5 του άρθρου 3 του ν. 998/1979, όπως ισχύει."

        # Finally add the signature
        paragraph8 = doc.add_paragraph()
        paragraph8.paragraph_format.left_indent = inch(8/2.54)
        paragraph8.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER
        run10 = paragraph8.add_run()
        run10.font.name = 'Arial'
        run10.font.size = pt(10)
        run10.bold = False
        run10.text = '\n\nΟ ΠΡΟΪΣΤΑΜΕΝΟΣ\nΤΜΗΜΑΤΟΣ ΔΑΣΙΚΩΝ ΧΑΡΤΟΓΡΑΦΗΣΕΩΝ\n\n'
        run10.text += self.dlg.plainTextEdit_2.toPlainText()

        # Save the document
        self._print('Το πιστοποιητικό δημιουργήθηκε με επιτυχία!')
        doc.save('Πιστοποιητικό.docx')
        return map_labels

    def make_diavivastiko(self, has_dasika, has_antir, has_exair, antir2exair, has_agrotika):
        # Create a new Document
        doc = docx.Document()

        # Access Inches and Points through the docx.shared module
        inch = docx.shared.Inches
        pt = docx.shared.Pt

        # Access the section of the document
        section = doc.sections[0]

        # Set margins (in inches)
        section.top_margin = inch(3/2.54)     # Top margin
        section.bottom_margin = inch(2/2.54)  # Bottom margin
        section.left_margin = inch(2/2.54)    # Left margin
        section.right_margin = inch(2/2.54)   # Right margin

        # Add the first table
        table1 = doc.add_table(1, 2)

        # Access the cells
        cell1 = table1.cell(0, 0)
        cell2 = table1.cell(0, 1)
        cell1.width = inch(11/2.54)
        cell2.width = inch(6/2.54)

        # Access the first paragraph in the first cell; if none exists, add one
        if not cell1.paragraphs:
            paragraph1 = cell1.add_paragraph()
        else:
            paragraph1 = cell1.paragraphs[0]

        # Add a run and insert the image
        run1 = paragraph1.add_run()
        run1.font.size = pt(10)
        run1.text = "                 "
        flag_path = os.path.join(self.dlg.documents_folder, FLAGNAME)
        run1.add_picture(flag_path, width=inch(0.6654), height=inch(0.6772))

        # Add another run and insert text
        run2 = paragraph1.add_run()
        run2.font.name = 'Arial'
        run2.font.size = pt(10)
        run2.bold = True
        run2.text = "\nΕΛΛΗΝΙΚΗ ΔΗΜΟΚΡΑΤΙΑ\nΥΠΟΥΡΓΕΙΟ ΠΕΡΙΒΑΛΛΟΝΤΟΣ & ΕΝΕΡΓΕΙΑΣ\nΓΕΝΙΚΗ ΓΡΑΜΜΑΤΕΙΑ ΔΑΣΩΝ\nΕΠΙΘΕΩΡΗΣΗ ΕΦΑΡΜΟΓΗΣ "
        self.epitheorisi = self.dlg.comboBox.currentText()
        if self.epitheorisi in ['ΑΙΓΑΙΟΥ', 'ΑΤΤΙΚΗΣ', 'ΚΡΗΤΗΣ']:
            run2.text += 'ΔΑΣΙΚΗΣ ΠΟΛΙΤΙΚΗΣ ' + self.epitheorisi + '\n'
        else:
            run2.text += 'ΔΑΣΙΚΗΣ ΠΟΛΙΤΙΚΗΣ' + '\n' + self.epitheorisi + '\n'
        run2.text += 'ΔΙΕΥΘΥΝΣΗ ΔΑΣΩΝ '+self.dlg.comboBox_2.currentText()+'\nΤΜΗΜΑ ΔΑΣΙΚΩΝ ΧΑΡΤΟΓΡΑΦΗΣΕΩΝ'

        # And another run for text
        run3 = paragraph1.add_run()
        run3.font.name = 'Arial'
        run3.font.size = pt(10)
        run3.bold = False
        run3.text = '\nΤαχ. Δ/νση: ' + self.dlg.lineEdit.text()
        run3.text += '\nΠληροφορίες: ' + self.dlg.lineEdit_2.text()
        run3.text += '\nΤηλέφωνο: ' + self.dlg.lineEdit_3.text()
        run3.text += '\nΗλ. Ταχ/μείο: ' + self.dlg.lineEdit_4.text()

        # Access the first paragraph in the second cell; if none exists, add one
        if not cell2.paragraphs:
            paragraph2 = cell2.add_paragraph()
        else:
            paragraph2 = cell2.paragraphs[0]

        # Add a run for Date & Protocol
        run4 = paragraph2.add_run()
        run4.font.name = 'Arial'
        run4.font.size = pt(10)
        run4.bold = False
        run4.italic = True
        run4.text = '\n\n\n'

        # Find the city where the forestry commission is located (edra)
        self.diefthinsi = self.dlg.comboBox_2.currentText()
        for value in self.dlg.EPITHEORISEIS[self.epitheorisi]:
            if value[0] == self.diefthinsi:
                self.edra = value[1]

        run4.text += self.edra + ', '
        run4.text += '\n' + 'Αρ. Πρωτ.: '
        run4.text += '\n\n\n\n'
        run4.text += 'Προς:\n'
        run4.text += self.dlg.plainTextEdit_3.toPlainText()

        # Add a 3rd title paragraph with bold text
        paragraph3 = doc.add_paragraph()
        paragraph3.alignment = WD_PARAGRAPH_ALIGNMENT.LEFT
        run5 = paragraph3.add_run()
        run5.font.name = 'Arial'
        run5.font.size = pt(10)
        run5.bold = True
        run5.text = '\nΘΕΜΑ:\tΑπάντηση σε αίτηση.'
        run5.text += "\nΣΧΕΤ.:\t(α) η υπ' αριθμόν " + self.dlg.lineEdit_5.text() + ' αίτησή σας.'
        if has_dasika: run5.text += "\n\t(β) το υπ' αριθμόν " + self.dlg.lineEdit_9.text() + '/' + self.dlg.lineEdit_10.text() + ' έγγραφό μας.'

        # Add the 4th main paragraph with text
        paragraph4 = doc.add_paragraph()
        paragraph4.alignment = WD_PARAGRAPH_ALIGNMENT.JUSTIFY
        run6 = paragraph4.add_run()
        run6.font.name = 'Arial'
        run6.font.size = pt(10)
        run6.bold = False

        if has_antir and not has_dasika and not has_exair and not has_agrotika:
            run6.text = '\n\tΣε απάντηση της ανωτέρω σχετικής (α) αίτησης, σας ενημερώνουμε ότι η έκταση για την οποία αιτηθήκατε την έκδοση πιστοποιητικού δασικού εν γένει χαρακτήρα, εμβαδού ' + self.dlg.lineEdit_7.text() + ' τ.μ., βρίσκεται εξ ολοκλήρου εντός έκτασης για την οποία εκκρεμεί αντίρρηση ενώπιον της ΕΠ.Ε.Α. και συνεπώς μη κυρωμένη.'
        elif has_exair and not has_dasika and not has_antir and not has_agrotika:
            run6.text = '\n\tΣε απάντηση της ανωτέρω σχετικής (α) αίτησης, σας ενημερώνουμε ότι η έκταση για την οποία αιτηθήκατε την έκδοση πιστοποιητικού δασικού εν γένει χαρακτήρα, εμβαδού ' + self.dlg.lineEdit_7.text() + ' τ.μ., βρίσκεται εξ ολοκλήρου εντός έκτασης η οποία εξαιρείται της ανάρτησης του δασικού χάρτη.' 
        elif (has_antir and not has_dasika and not has_exair and has_agrotika) or (has_antir and has_dasika and not has_exair and has_agrotika) or (has_antir and has_dasika and not has_exair and not has_agrotika):
            sca = self.simple_count('Αντιρρήσεις')
            if  sca == 1:
                run6.text = '\n\tΣε απάντηση της ανωτέρω σχετικής (α) αίτησής σας, σας ενημερώνουμε ότι εντός της έκτασης για την οποία αιτηθήκατε την έκδοση πιστοποιητικού δασικού εν γένει χαρακτήρα έκτασης εντοπίζεται τμήμα για το οποίο εκκρεμούν αντιρρήσεις ενώπιον της ΕΠ.Ε.Α. και συνεπώς μη κυρωμένο:'
            else:
                run6.text = '\n\tΣε απάντηση της ανωτέρω σχετικής (α) αίτησής σας, σας ενημερώνουμε ότι εντός της έκτασης για την οποία αιτηθήκατε την έκδοση πιστοποιητικού δασικού εν γένει χαρακτήρα έκτασης εντοπίζονται τμήματα για τα οποία εκκρεμούν αντιρρήσεις ενώπιον της ΕΠ.Ε.Α. και συνεπώς μη κυρωμένα:'

            # Work the attribute table
            a_layer = PROJECT.mapLayersByName('Αντιρρήσεις')[0]
            features = a_layer.getFeatures()
            featureList = []
            for feat in features:
                featureList.append([round(feat.attributes()[1],4), self.coords(feat.geometry())])
            featureList.sort(key=lambda x: -x[0])

            # Add the needed table
            table = doc.add_table(rows=sca, cols=1)
            _counter = 0
            for row in table.rows:
                cell = row.cells[0]
                cell.width = inch(5.2/2.54)
                self.set_cell_borders(cell)
                paragraph5 = cell.paragraphs[0]
                run7 = paragraph5.add_run('ΤΜΗΜΑ'+str(_counter+1)+'\n'+featureList[_counter][1]+'\n'+'Εμβαδόν (τ.μ.): '+self.transform(featureList[_counter][0]))
                run7.font.name = 'Arial'
                run7.font.size = pt(9)
                run7.font.bold = False
                paragraph5.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER
                _counter += 1

        elif (has_exair and not has_dasika and not has_antir and has_agrotika) or (has_exair and has_dasika and not has_antir and has_agrotika) or (has_exair and has_dasika and not has_antir and not has_agrotika):
            sce = self.simple_count('Εξαιρέσεις')
            if sce == 1:
                run6.text = '\n\tΣε απάντηση της ανωτέρω σχετικής (α) αίτησής σας, σας ενημερώνουμε ότι εντός της έκτασης για την οποία αιτηθήκατε την έκδοση πιστοποιητικού δασικού εν γένει χαρακτήρα έκτασης εντοπίζεται τμήμα το οποίο εξαιρείται της ανάρτησης του δασικού χάρτη:'
            else:
                run6.text = '\n\tΣε απάντηση της ανωτέρω σχετικής (α) αίτησής σας, σας ενημερώνουμε ότι εντός της έκτασης για την οποία αιτηθήκατε την έκδοση πιστοποιητικού δασικού εν γένει χαρακτήρα έκτασης εντοπίζονται τμήματα τα οποία εξαιρούνται της ανάρτησης του δασικού χάρτη:'

            # Work the attribute table
            e_layer = PROJECT.mapLayersByName('Εξαιρέσεις')[0]
            features = e_layer.getFeatures()
            featureList = []
            for feat in features:
                featureList.append([round(feat.attributes()[1],4), self.coords(feat.geometry())])
            featureList.sort(key=lambda x: -x[0])

            # Add the needed table
            table = doc.add_table(rows=sce, cols=1)
            _counter = 0
            for row in table.rows:
                cell = row.cells[0]
                cell.width = inch(5.2/2.54)
                self.set_cell_borders(cell)
                paragraph5 = cell.paragraphs[0]
                run7 = paragraph5.add_run('ΤΜΗΜΑ'+str(_counter+1)+'\n'+featureList[_counter][1]+'\n'+'Εμβαδόν (τ.μ.): '+self.transform(featureList[_counter][0]))
                run7.font.name = 'Arial'
                run7.font.size = pt(9)
                run7.font.bold = False
                paragraph5.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER
                _counter += 1

        elif (has_exair and has_antir and not has_dasika and not has_agrotika) or (has_exair and has_antir and has_dasika and not has_agrotika) or (has_exair and has_antir and not has_dasika and has_agrotika) or (has_exair and has_antir and has_dasika and has_agrotika):
            if antir2exair:
                antirshp = 'Αντιρρήσεις_2'
            else:
                antirshp = 'Αντιρρήσεις'
            sca = self.simple_count(antirshp)

            if  sca == 1:
                run6.text = '\n\tΣε απάντηση της ανωτέρω σχετικής (α) αίτησής σας, σας ενημερώνουμε ότι εντός της έκτασης για την οποία αιτηθήκατε την έκδοση πιστοποιητικού δασικού εν γένει χαρακτήρα έκτασης εντοπίζεται τμήμα για το οποίο εκκρεμούν αντιρρήσεις ενώπιον της ΕΠ.Ε.Α. και συνεπώς μη κυρωμένο:'
            else:
                run6.text = '\n\tΣε απάντηση της ανωτέρω σχετικής (α) αίτησής σας, σας ενημερώνουμε ότι εντός της έκτασης για την οποία αιτηθήκατε την έκδοση πιστοποιητικού δασικού εν γένει χαρακτήρα έκτασης εντοπίζονται τμήματα για τα οποία εκκρεμούν αντιρρήσεις ενώπιον της ΕΠ.Ε.Α. και συνεπώς μη κυρωμένα:'

            a_layer = PROJECT.mapLayersByName(antirshp)[0]
            features = a_layer.getFeatures()
            featureList = []
            for feat in features:
                featureList.append([round(feat.attributes()[1],4), self.coords(feat.geometry())])
            featureList.sort(key=lambda x: -x[0])

            # Add the needed table
            table = doc.add_table(rows=sca, cols=1)
            _counter = 0
            for row in table.rows:
                cell = row.cells[0]
                cell.width = inch(5.2/2.54)
                self.set_cell_borders(cell)
                paragraph5 = cell.paragraphs[0]
                run7 = paragraph5.add_run('ΤΜΗΜΑ'+str(_counter+1)+'\n'+featureList[_counter][1]+'\n'+'Εμβαδόν (τ.μ.): '+self.transform(featureList[_counter][0]))
                run7.font.name = 'Arial'
                run7.font.size = pt(9)
                run7.font.bold = False
                paragraph5.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER
                _counter += 1

            # Add the next paragraph with text
            paragraph6 = doc.add_paragraph()
            paragraph6.alignment = WD_PARAGRAPH_ALIGNMENT.JUSTIFY
            run8 = paragraph6.add_run()
            run8.font.name = 'Arial'
            run8.font.size = pt(10)
            run8.bold = False

            sce = self.simple_count('Εξαιρέσεις')
            if sce == 1:
                run8.text = '\n\tΕπίσης εντός της έκτασης για την οποία αιτηθήκατε την έκδοση πιστοποιητικού δασικού εν γένει χαρακτήρα έκτασης εντοπίζεται τμήμα το οποίο εξαιρείται της ανάρτησης του δασικού χάρτη:'
            else:
                run8.text = '\n\tΕπίσης εντός της έκτασης για την οποία αιτηθήκατε την έκδοση πιστοποιητικού δασικού εν γένει χαρακτήρα έκτασης εντοπίζονται τμήματα τα οποία εξαιρούνται της ανάρτησης του δασικού χάρτη:'

            # Work the attribute table
            e_layer = PROJECT.mapLayersByName('Εξαιρέσεις')[0]
            features = e_layer.getFeatures()
            featureList = []
            for feat in features:
                featureList.append([round(feat.attributes()[1],4), self.coords(feat.geometry())])
            featureList.sort(key=lambda x: -x[0])

            # Add the needed table
            table = doc.add_table(rows=sce, cols=1)
            _counter = 0
            for row in table.rows:
                cell = row.cells[0]
                cell.width = inch(5.2/2.54)
                self.set_cell_borders(cell)
                paragraph7 = cell.paragraphs[0]
                run9 = paragraph7.add_run('ΤΜΗΜΑ'+str(_counter+1)+'\n'+featureList[_counter][1]+'\n'+'Εμβαδόν (τ.μ.): '+self.transform(featureList[_counter][0]))
                run9.font.name = 'Arial'
                run9.font.size = pt(9)
                run9.font.bold = False
                paragraph7.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER
                _counter += 1

        # Add the last paragraph
        if has_dasika:
            paragraph8 = doc.add_paragraph()
            paragraph8.alignment = WD_PARAGRAPH_ALIGNMENT.JUSTIFY
            run10 = paragraph8.add_run()
            run10.font.name = 'Arial'
            run10.font.size = pt(10)
            run10.bold = False
            run10.text = "\nΓια τις υπόλοιπες, εντός της αιτηθείσας έκτασης, δασικού χαρακτήρα εκτάσεις έχει εκδοθεί το σχετικό (β) πιστοποιητικό μας."

        # Finally add the signature
        paragraph9 = doc.add_paragraph()
        paragraph9.paragraph_format.left_indent = inch(8/2.54)
        paragraph9.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER
        run11 = paragraph9.add_run()
        run11.font.name = 'Arial'
        run11.font.size = pt(10)
        run11.bold = False
        run11.text = '\n\nΟ ΔΙΕΥΘΥΝΤΗΣ ΔΑΣΩΝ '+self.dlg.comboBox_2.currentText()+'\n\n'
        run11.text += self.dlg.plainTextEdit_5.toPlainText()

        # Save the document
        self._print('Το διαβιβαστικό δημιουργήθηκε με επιτυχία!')
        doc.save('Διαβιβαστικό.docx')

    def make_the_map(self, map_labels):
        # Remove print layout if any
        layout_name = "My_Map_Layout"
        manager = PROJECT.layoutManager()
        # Find the layout by name
        _layout = manager.layoutByName(layout_name)
        if _layout:
            # Remove the layout from the project
            manager.removeLayout(_layout)
            self._print("Previous layout has been removed.")

        # Create a new print layout
        layout = QgsPrintLayout(PROJECT)
        layout.initializeDefaults()

        # Set page size to A3 landscape (420mm x 297mm)
        page_size = QgsLayoutSize(420, 297, QgsUnitTypes.LayoutMillimeters)
        layout.pageCollection().pages()[0].setPageSize(page_size)

        # Set the layout name
        layout.setName(layout_name)

        if manager.addLayout(layout):
            # Hide all the layers
            self.hide_everything()

            # First make the small map
            self.disable_layer(kanavos,1)
            kanavos_layer = PROJECT.mapLayersByName(kanavos)[0]
            kanavos_item = QgsLayoutItemMap(layout)
            kanavos_item.setBackgroundColor(QColor(255, 255, 255, 0))  # white/transparent background
            kanavos_item.setRect(0, 0, 0, 0)
            kanavos_item.attemptMove(QgsLayoutPoint(5, 60))
            kanavos_item.attemptResize(QgsLayoutSize(110, 85))
            # Enable border/frame
            kanavos_item.setFrameEnabled(True)
            kanavos_item.setFrameStrokeColor(QColor(0, 0, 0))  # black border
            width = 0.3  # your desired width
            measurement = QgsLayoutMeasurement(width)
            kanavos_item.setFrameStrokeWidth(measurement)  # in mm
            # Add the map item to the layout
            layout.addLayoutItem(kanavos_item)
            kanavos_item.setExtent(kanavos_layer.extent())
            # Now Resize again
            kanavos_item.attemptResize(QgsLayoutSize(110, 85))
            _k = self.normalize_kanavos_scale(kanavos_item)
            # Store current layer styles and visibility
            kanavos_item.storeCurrentLayerStyles()
            # Set specific layers
            kanavos_item.setLayers([kanavos_layer])
            # Create a scale text layout item
            small_text_item = QgsLayoutItemLabel(layout)
            small_text_item.setText('ΚΛΙΜΑΚΑ 1:' + str(_k))
            # Set background color to white
            small_text_item.setBackgroundEnabled(True)
            small_text_item.setBackgroundColor(QColor('white'))
            # Remove frame (border)
            small_text_item.setFrameEnabled(False)
            # Set position and size with QRectF (x, y, width, height)
            small_rect = QRectF(42.5, 142.65, 35, 5)  # Adjust as needed
            small_text_item.adjustSizeToText()
            small_text_item.attemptSetSceneRect(small_rect)
            # Set alignments
            small_text_item.setHAlign(Qt.AlignCenter)
            small_text_item.setVAlign(Qt.AlignCenter)
            # Add the text item to the layout
            layout.addLayoutItem(small_text_item)
            small_text_item.setLocked(True)

            # Now work with the main map
            self.enable_rasters()
            self.disable_layer('Κτήμα',1)
            ktima_layer = PROJECT.mapLayersByName('Κτήμα')[0]
            # Create the main map item
            map_item = QgsLayoutItemMap(layout)
            map_item.setBackgroundColor(QColor(255, 255, 255, 0))  # white/transparent background
            map_item.setRect(0, 0, 0, 0)
            map_item.attemptMove(QgsLayoutPoint(120, 8.5))
            map_item.attemptResize(QgsLayoutSize(280, 280))
            # Create the overview of the small item
            overview_obj = kanavos_item.overview()
            overview_obj.setLinkedMap(map_item)
            obj_symbol = QgsFillSymbol.createSimple({'color': 'red', 'outline_color': 'red', 'outline_width': '5'})
            overview_obj.setFrameSymbol(obj_symbol)
            kanavos_item.setLocked(True)

            # Enabling and painting
            symbol1 = QgsFillSymbol.createSimple({'color': 'transparent', 'outline_color': 'red', 'outline_width': '1'})
            ktima_layer.renderer().setSymbol(symbol1)
            ktima_layer.triggerRepaint()
            self.disable_layer('Δασικά',1)
            dasika_layer = PROJECT.mapLayersByName('Δασικά')[0]
            # Add a line pattern fill layer
            symbol2 = QgsFillSymbol.createSimple({'color': 'transparent', 'outline_color': 'green', 'outline_width': '1'})
            pattern_layer = QgsLinePatternFillSymbolLayer()
            pattern_layer.setFillColor(QColor('green'))
            pattern_layer.setLineWidth(1)
            pattern_layer.setLineAngle(45)  # rotation in degrees
            pattern_layer.setColor(QColor('green'))
            symbol2.appendSymbolLayer(pattern_layer)
            dasika_layer.renderer().setSymbol(symbol2)
            # Refresh the layer
            dasika_layer.triggerRepaint()

            # Now create the grid
            map_grid = QgsLayoutItemMapGrid("my_grid",map_item)
            map_grid.setStyle(QgsLayoutItemMapGrid.Cross)

            # Enable border/frame
            map_item.setFrameEnabled(True)
            map_item.setFrameStrokeColor(QColor(0, 0, 0))  # black border
            width = 0.3  # your desired width
            measurement = QgsLayoutMeasurement(width)
            map_item.setFrameStrokeWidth(measurement)  # in mm
            map_grid.setFrameStyle(QgsLayoutItemMapGrid.LineBorder)
            map_item.grids().addGrid(map_grid) 

            # Set the grid annotations
            map_grid.AnnotationCoordinate = QgsLayoutItemMapGrid.AnnotationCoordinate
            map_grid.setAnnotationFormat(QgsLayoutItemMapGrid.Decimal)
            map_grid.setAnnotationPrecision(0)
            map_grid.setAnnotationDisplay(QgsLayoutItemMapGrid.DisplayMode.LatitudeOnly,QgsLayoutItemMapGrid.Right)
            map_grid.setAnnotationDirection(QgsLayoutItemMapGrid.AnnotationDirection.Vertical,QgsLayoutItemMapGrid.Right)
            map_grid.setAnnotationDisplay(QgsLayoutItemMapGrid.DisplayMode.LongitudeOnly,QgsLayoutItemMapGrid.Bottom)
            map_grid.setAnnotationDirection(QgsLayoutItemMapGrid.AnnotationDirection.Horizontal,QgsLayoutItemMapGrid.Bottom)
            map_grid.setAnnotationDisplay(QgsLayoutItemMapGrid.DisplayMode.HideAll,QgsLayoutItemMapGrid.Left)
            map_grid.setAnnotationDisplay(QgsLayoutItemMapGrid.DisplayMode.HideAll,QgsLayoutItemMapGrid.Top)
            # Optional: set font and color
            map_grid.setAnnotationFont(QFont("Arial", 8))
            map_grid.setAnnotationFontColor(QColor(0, 0, 0))
            map_grid.setAnnotationEnabled(True)

            # Create and customize a scalebar item
            scalebar = QgsLayoutItemScaleBar(layout)
            # Set position and size
            scalebar.attemptMove(QgsLayoutPoint(122, 10.5, QgsUnitTypes.LayoutMillimeters))
            scalebar.attemptResize(QgsLayoutSize(100, 20, QgsUnitTypes.LayoutMillimeters))
            # Set the style to 'Single Box' or preferred style
            scalebar.setStyle('Single Box')
            # Set units (e.g., meters)
            scalebar.setUnits(QgsUnitTypes.DistanceMeters)
            scalebar.setSegmentSizeMode(QgsScaleBarSettings.SegmentSizeMode.FitWidth)
            scalebar.setNumberOfSegments(2)
            scalebar.setMinimumBarWidth(30)
            scalebar.setMaximumBarWidth(50)
            scalebar.setBackgroundEnabled(True)
            scalebar.setBackgroundColor(QColor(255, 255, 255))
            scalebar.setFrameEnabled(True)
            scalebar.setFrameStrokeColor(QColor(0, 0, 0))  # black border
            measurement = QgsLayoutMeasurement(0.3) # your desired width
            scalebar.setFrameStrokeWidth(measurement)  # in mm
            # Add the scalebar to the layout
            layout.addLayoutItem(scalebar)
            scalebar.setLinkedMap(map_item)
            scalebar.refresh()
            scalebar.setLocked(True)

            # Add the map item to the layout
            layout.addLayoutItem(map_item)
            ktima_extent = self.fit_layer_extent_to_layout_extent(ktima_layer)
            map_item.setExtent(ktima_extent)
            map_item.setLocked(True)

            # Now Resize again
            map_item.attemptResize(QgsLayoutSize(280, 280))
            _s = self.normalize_scale(map_item)
            _s_ = _s/36.66
            map_grid.setIntervalX(_s_)
            map_grid.setIntervalY(_s_)
            # Store current layer styles and visibility
            map_item.storeCurrentLayerStyles()
            # Set specific layers
            rasters_layers = self.gather_rasters()
            specific_layers = [ktima_layer, dasika_layer] + rasters_layers
            map_item.setLayers(specific_layers)

            # Create the scale text layout item
            scale_text_item = QgsLayoutItemLabel(layout)
            scale_text_item.setText('ΚΛΙΜΑΚΑ 1:'+str(_s))
            # Set background color to white
            scale_text_item.setBackgroundEnabled(True)
            scale_text_item.setBackgroundColor(QColor('white'))
            # Remove frame (border)
            scale_text_item.setFrameEnabled(False)
            # Set position and size with QRectF (x, y, width, height)
            rect = QRectF(124, 24, 35, 5)  # Adjust as needed
            scale_text_item.attemptSetSceneRect(rect)
            # Add the text item to the layout
            layout.addLayoutItem(scale_text_item)
            scale_text_item.setLocked(True)

            # Create the map labels
            ppwu = map_item.pagePositionWithUnits()
            for item in map_labels:
                # Create a new map_label
                map_label = QgsLayoutItemLabel(layout)
                map_label.setText(item[0])
                map_label.setHAlign(Qt.AlignCenter)
                map_label.setVAlign(Qt.AlignCenter)
                map_label.setFontColor(QColor('white'))
                map_label.setFont(QFont("Arial", 10))
                # Set size
                label_width = 30
                label_height = 10
                map_label.setFixedSize(QgsLayoutSize(label_width, label_height, QgsUnitTypes.LayoutMillimeters))
                # Add the label to the layout
                layout.addLayoutItem(map_label)
                # Set label position
                mtic = map_item.mapToItemCoords(QPointF(item[1], item[2]))
                map_label.setPos(mtic.x() + ppwu.x()-(label_width/2), mtic.y() + ppwu.y()-(label_height/2))
                map_label.setLocked(True)

            # Path to north arrow image
            north_path = os.path.join(self.dlg.documents_folder, NORTH)
            # Create picture item
            north_arrow = QgsLayoutItemPicture(layout)
            north_arrow.setPicturePath(north_path)
            # Position and size (adjust as needed)
            rect = QRectF(375, 265, 20, 20)  # x, y, width, height
            north_arrow.attemptSetSceneRect(rect)
            # Add to layout
            layout.addLayoutItem(north_arrow)
            north_arrow.setLocked(True)
            # Refresh layout
            layout.refresh()

            # All the other labels - first the big outline on the left
            big_label = QgsLayoutItemLabel(layout)
            # Set background color to transparent
            big_label.setBackgroundEnabled(False)
            # Enable frame (border)
            big_label.setFrameEnabled(True)
            # Set position and size with QRectF (x, y, width, height)
            big_rect = QRectF(5, 8.5, 110, 280)  # Adjust as needed
            big_label.attemptSetSceneRect(big_rect)
            big_label.setFrameStrokeColor(QColor('black'))  # border color
            width = 0.3  # your desired width
            measurement = QgsLayoutMeasurement(width)
            big_label.setFrameStrokeWidth(measurement)  # in mm
            # Add the item to the layout
            layout.addLayoutItem(big_label)
            big_label.setLocked(True)

            # Then the colored ones
            y = 150
            for _color in ['green','red']:
                color_label = QgsLayoutItemLabel(layout)
                # Set background color to white
                color_label.setBackgroundEnabled(True)
                color_label.setBackgroundColor(QColor('white'))
                # Enable frame (border)
                color_label.setFrameEnabled(True)
                # Set position and size with QRectF (x, y, width, height)
                color_rect = QRectF(8, y, 7, 3)  # Adjust as needed
                color_label.attemptSetSceneRect(color_rect)
                color_label.setFrameStrokeColor(QColor(_color))  # border color
                width = 1  # your desired width
                measurement = QgsLayoutMeasurement(width)
                color_label.setFrameStrokeWidth(measurement)  # in mm
                # Add the item to the layout
                layout.addLayoutItem(color_label)
                color_label.setLocked(True)
                y += 5

            y = 150
            for _text in ['Έκταση για την οποία εκδίδεται το πιστ/κό της παρ. 4 του αρθ. 20 του Ν. 3889/2010','Όριο γεωτεμαχίου αιτήματος']:
                color_text_label = QgsLayoutItemLabel(layout)
                # Set background color to white
                color_text_label.setBackgroundEnabled(True)
                color_text_label.setBackgroundColor(QColor('white'))
                # Disable frame (border)
                color_text_label.setFrameEnabled(False)
                color_text_label.setText(_text)
                color_text_label.setFontColor(QColor('black'))
                color_text_label.setFont(QFont("Arial", 7))
                # Set position and size with QRectF (x, y, width, height)
                color_text_rect = QRectF(17, y, 95, 3)  # Adjust as needed
                color_text_label.attemptSetSceneRect(color_text_rect)
                # Add the text item to the layout
                layout.addLayoutItem(color_text_label)
                color_text_label.setLocked(True)
                y += 5

            # Now the table labels
            tbl_a = "«Δασική» έκταση, στους «Ιστορικούς Ορθοφωτοχάρτες 1945 (1960)» ή προκύπτει από προϋφιστάμενα της παλαιότερης αεροφωτογράφισης εφαρμόσιμα στοιχεία -«Δασική» έκταση στις πρόσφατες Α/Φ."
            tbl_b = "«Δασική» έκταση, στους «Ιστορικούς Ορθοφωτοχάρτες 1945 (1960)» ή προκύπτει από προϋφιστάμενα της παλαιότερης αεροφωτογράφισης εφαρμόσιμα στοιχεία -«Άλλης μορφής/κάλυψης» έκταση στις πρόσφατες Α/Φ ή βάσει παραχωρητηρίων."
            tbl_c = "«Άλλης μορφής/κάλυψης» έκταση στους «Ιστορικούς Ορθοφωτοχάρτες 1945 (1960)» - «Δασική» έκταση, στις πρόσφατες Α/Φ"
            tbl_d = "«Χορτολιβαδική» έκταση στους «Ιστορικούς Ορθοφωτοχάρτες 1945 (1960)» - «Χορτολιβαδική» έκταση στις πρόσφατες Α/Φ."
            tbl_e = "«Χορτολιβαδική» έκταση στους «Ιστορικούς Ορθοφωτοχάρτες 1945 (1960)» - «Άλλης μορφής/κάλυψης» έκταση στις πρόσφατες Α/Φ."
            tbl_f = "«Άλλης μορφής/κάλυψης» έκταση στους «Ιστορικούς Ορθοφωτοχάρτες 1945 (1960)» (μόνο για κατακλυζόμενες από ύδατα εκτάσεις) «Χορτολιβαδική» έκταση στις πρόσφατες Α/Φ."
            tbl_g = "Αναδασωτέα ή Δασωτέα έκταση με πράξη της αρμόδιας αρχής."
            tbl_h = "Τελεσίδικες πράξεις και αποφάσεις χαρακτηρισμού (παρ. 18 του άρθρου 28 του ν. 2664/98), με τις οποίες η έκταση χαρακτηρίστηκε ως «Δασική»."
            tbl_i = "Τελεσίδικες πράξεις και αποφάσεις χαρακτηρισμού (παρ. 18 του άρθρου 28 του ν. 2664/98), με τις οποίες η έκταση χαρακτηρίστηκε ως «Χορτολιβαδική»."
            table_labels = [['ΔΔ',tbl_a,10],['ΔΑ',tbl_b,13],['ΑΔ',tbl_c,7],['ΧΧ',tbl_d,7],['ΧΑ',tbl_e,7],['ΑΧ',tbl_f,10],['ΑΝ',tbl_g,4],['ΠΔ',tbl_h,10],['ΠΧ',tbl_i,10]]
            y = 160
            for tbl in table_labels:
                tbl_label1 = QgsLayoutItemLabel(layout)
                tbl_label2 = QgsLayoutItemLabel(layout)
                # Set background color to white
                tbl_label1.setBackgroundEnabled(True)
                tbl_label1.setBackgroundColor(QColor('white'))
                tbl_label2.setBackgroundEnabled(True)
                tbl_label2.setBackgroundColor(QColor('white'))
                # Enable frame (border)
                tbl_label1.setFrameEnabled(True)
                tbl_label2.setFrameEnabled(True)
                # Set alignment of first cell
                tbl_label1.setHAlign(Qt.AlignCenter)
                tbl_label1.setVAlign(Qt.AlignCenter)
                # Set the text
                tbl_label1.setText(tbl[0])
                tbl_label2.setText(tbl[1])
                # Set the fonts
                tbl_label1.setFontColor(QColor('black'))
                tbl_label1.setFont(QFont("Arial", 8))
                tbl_label2.setFontColor(QColor('black'))
                tbl_label2.setFont(QFont("Arial", 8))
                # Set position and size with QRectF (x, y, width, height)
                tbl_rect1 = QRectF(8, y, 15, tbl[2])  # Adjust as needed
                tbl_label1.attemptSetSceneRect(tbl_rect1)
                tbl_rect2 = QRectF(23, y, 90, tbl[2])  # Adjust as needed
                tbl_label2.attemptSetSceneRect(tbl_rect2)
                # Add the items to the layout
                layout.addLayoutItem(tbl_label1)
                layout.addLayoutItem(tbl_label2)
                tbl_label1.setLocked(True)
                tbl_label2.setLocked(True)
                y += tbl[2]

            # Now the top label
            top_label = QgsLayoutItemLabel(layout)
            top_text = "ΥΠΟΥΡΓΕΙΟ ΠΕΡΙΒΑΛΛΟΝΤΟΣ & ΕΝΕΡΓΕΙΑΣ\nΓΕΝΙΚΗ ΓΡΑΜΜΑΤΕΙΑ ΔΑΣΩΝ\nΕΠΙΘΕΩΡΗΣΗ ΕΦΑΡΜΟΓΗΣ "
            epitheorisi = self.dlg.comboBox.currentText()
            if epitheorisi in ['ΑΙΓΑΙΟΥ', 'ΑΤΤΙΚΗΣ', 'ΚΡΗΤΗΣ']:
                top_text += 'ΔΑΣΙΚΗΣ ΠΟΛΙΤΙΚΗΣ ' + self.epitheorisi + '\n'
            else:
                top_text += 'ΔΑΣΙΚΗΣ ΠΟΛΙΤΙΚΗΣ' + '\n' + epitheorisi + '\n'
            top_text += 'ΔΙΕΥΘΥΝΣΗ ΔΑΣΩΝ '+self.dlg.comboBox_2.currentText()+'\n'
            top_text += '\nΔασικός Χάρτης '+ self.dlg.plainTextEdit.toPlainText() + '.'
            top_label.setText(top_text)
            top_label.setHAlign(Qt.AlignCenter)
            top_label.setVAlign(Qt.AlignCenter)
            top_label.setFontColor(QColor('black'))
            top_label.setFont(QFont("Arial", 9))
            top_rect = QRectF(5, 8.5, 110, 50)  # Adjust as needed
            top_label.attemptSetSceneRect(top_rect)
            # Add the item to the layout
            layout.addLayoutItem(top_label)
            top_label.setLocked(True)

            # Last the signature label
            sign_label = QgsLayoutItemLabel(layout)
            sign_text = "ΠΡΟΣΑΡΤΑΤΑΙ ΣΤΟ ΜΕ ΑΡ. ΠΡΩΤ. " + self.dlg.lineEdit_9.text() + " ΠΙΣΤΟΠΟΙΗΤΙΚΟ\nΔΑΣΙΚΟΥ ΕΝ ΓΕΝΕΙ ΧΑΡΑΚΤΗΡΑ ΕΚΤΑΣΗΣ\n\n" + self.edra + " " + self.dlg.lineEdit_10.text() + "\nΟ ΠΡΟΪΣΤΑΜΕΝΟΣ\nΤΜΗΜΑΤΟΣ ΔΑΣΙΚΩΝ ΧΑΡΤΟΓΡΑΦΗΣΕΩΝ\n\n" + self.dlg.plainTextEdit_2.toPlainText()
            sign_label.setText(sign_text)
            sign_label.setHAlign(Qt.AlignCenter)
            sign_label.setVAlign(Qt.AlignCenter)
            sign_label.setFontColor(QColor('black'))
            sign_label.setFont(QFont("Arial", 9))
            sign_rect = QRectF(5, 238, 110, 50)  # Adjust as needed
            sign_label.attemptSetSceneRect(sign_rect)
            # Add the item to the layout
            layout.addLayoutItem(sign_label)
            sign_label.setLocked(True)

            # Save the layout as a PDF
            exporter = QgsLayoutExporter(layout)
            exporter.exportToPdf('ΧΑΡΤΗΣ.pdf', QgsLayoutExporter.PdfExportSettings())
            self._print("Map created successfully!")
        else:
            self._print('Something went wrong with the map...')

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = pdxDialog()

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Change the current working directory
            working_folder = os.path.dirname(self.dlg.lineEdit_8.text())
            try:
                os.chdir(working_folder)
            except OSError as error:
                self._print(error)

            # Create the log file
            if not os.path.exists(FILENAME2):
                open(FILENAME2, 'x').close()
            else:
                open(FILENAME2, 'w').close()

            # Run the actual program

            # First make the necessary shapefiles
            var0 = self.dxf_to_shp()
            if var0:
                var1 = self.dasika_to_shp()
                var2 = self.antir_to_shp()
                var3 = self.exair_to_shp()
                var4 = 0
                if var2 and var3:
                    var4 = self.antir_to_exair()
                var5 = self.agrotika_to_shp()

                # Then make the documents
                if var1:
                    var6 = self.make_the_pdx()
                    self.make_the_map(var6)
                if var2 or var3:
                    self.make_diavivastiko(var1, var2, var3, var4, var5)
